# 동적 계획법(Dynamic Programming)

- 통상적으로 <u>메모리를 더 사용하여</u> 시간복잡도를 개선할 때 많이 사용된다.
- 구체적으로, 시간 복잡도가 비효율적인 알고리즘이 있을 때 <b>부분 문제의 반복</b>이 발생하는 경우 적용하면 효과적이다.
- 다이나믹 프로그래밍 문제를 해결하기 위해 <b>점화식</b>을 찾는 것이 핵심적인 과정이다.

## 다이나믹 프로그래밍의 사용 조건

- 다이나믹 프로그래밍은 일반적으로 아래의 두 조건을 만족할 때 사용할 수 있다.

1. 최적 부분 구조(optimal substructure)

- 큰 문제를 유사한 형태의 작은 문제로 나눌 수 있으며, 작은 문제의 답을 모아 큰 문제를 해결한다.

2. 반복되는 부분 문제(overlapping sub-problem)

- 동일한 작은 문제를 반복적으로 해결해야 한다.

## 점화식과 최적 부분 구조

- 피보나치 수열 예시: <code>[1,1,2,3,5,8,13,21,34,55,89,...]</code>
- 점화식: 인접한 항으로 현재 값을 결정하는 관계식을 의미한다.
  - 일반적으로 <b>최적 부분 구조</b>를 만족한다는 특징이 있다.
- a1 = 1, a2 = 1 과 같이 초기식이 필요하다.
- 점화식은 재귀함수로서 표현될 수 있다.

## 점화식의 구성요소

- 점화식의 기본적인 구성 요소는 다음과 같다.

1. 초기항
2. 인접한 항과의 관계

- 점화식은 [재귀함수]로 표현할 수 있다.
- 재귀 함수는 [종료 조건]이 있어야 하는데, 이것이 점화식의 초기항과 같은 역할을 수행한다.

```javascript
// 피보나치 함수를 재귀함수로 표현
function fibo(x) {
  if (x === 1 || x === 2) {
    return 1;
  }
  return fibo(x - 1) + fibo(x - 2);
}
console.log(fibo(4));
```

## 점화식을 코드로 구현하는 방법

- 점화식을 재귀 함수 코드로 구현할 수 있다.

1. 점화식의 초기항은 종료 조건과 같은 역할을 수행한다.
2. 점화식의 내용은 f(x)의 반환 값에 들어간다.

```javascript
// 피보나치 함수를 재귀함수로 표현
function fibo(x) {
  // 종료 조건이 없으면 무한 루프
  if (x === 1 || x === 2) {
    return 1;
  }
  // 실질적인 점화식 부분
  return fibo(x - 1) + fibo(x - 2);
}
console.log(fibo(4));
```

이 하나의 함수는 두 개의 재귀함수를 호출하기 때문에 시간복잡도상 심각한 비효율성을 야기할 수 있다.

## 피보나치 수열 문제

- 피보나치 수열 문제는 다음의 조건을 만족한다.

1. 최적 부분 구조 -> 점화식 형태로 표현 가능
2. 반복되는 부분 문제

- 이미 해결한 문제를 또 해결해야 한다.

## 다이나믹 프로그래밍의 일반 형태

- 피보나치 수열의 점화식을 그대로 재귀 함수로 구현하면 어떻게 될까?
  - 중복되는 부분 문제가 발생한다. (이미 구한 값을 불필요하게 반복 계산)
- 다이나믹 프로그래밍은 이 문제를 해결할 수 있도록 해준다.

```javascript
d = new Array(100).fill(0); // 한 번 계산된 결과를 메모이제이션(Memoization)하기 위한 리스트 초기화
function fibo(x) {
  // 피보나치 함수를 재귀함수로 구현 (탑다운 다이나믹 프로그래밍)
  if (x === 1 || x === 2) {
    // 종료 조건(1 혹은 2일 때 1을 반환)
    return 1;
  }
  // 이미 계산한 적 있는 문제라면 그대로 반환
  if (d[x] !== 0) {
    return d[x];
  }
  // 아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
  d[x] = fibo(x - 1) + fibo(x - 2);
  return d[x];
}
console.log(fibo(99));
```

- <b>탑다운</b>이란 큰 문제를 해결하기 위해서 작은 문제를 모아서 해결하는 것을 얘기한다. (기본적으로 재귀함수가 탑다운 방식임)
- 다이나믹 프로그래밍의 대표적인 코드 형식은 다음과 같다.
  - ```javascript
      function dp() {
          1. 종료 조건
          2. 이미 해결한 문제라면, 정답을 그대로 반환
          3. 점화식에 따라 정답 계산
      }
    ```

## 다이나믹 프로그래밍 문제 해결 과정

1. 문제 이해하기
2. 점화식 찾아내기 -> 일반적으로 가장 핵심적인 부분
3. 구현 방식(상향식/하향식) 결정하기
4. 점화식을 실제 코드로 구현하기

## 다이나믹 프로그래밍 문제 접근 방법

1. 상향식: 반복문을 이용해 초기 항부터 계산한다.
2. 하향식: 재귀 함수로 큰 항을 구하기 위해 작은(DP) 항을 호출하는 방식이다.
   -> 이미 구한 함수 값을 담는 테이블은 흔히 DP 테이블이라고 한다.

재귀 함수가 많이 호출되는 경우에는 Stack overflow가 발생할 수 있기 때문에, 만약에 동일한 상황이라고 하면 <b>상향식</b>접근 방법이 추천된다.

## 피보나치 수열(상향식)

```javascript
// 앞서 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = new Array(100).fill(0);

// 첫 번째 피보나치 수와 두 번째 피보나치 수는 1
d[1] = 1;
d[2] = 1;
n = 99;

// 피보나치 함수 반복문으로 구현(바텀업 다이나믹 프로그래밍)
for (let i = 3; i <= n; i++) {
  d[i] = d[i - 1] + d[i - 2];
}

console.log(d[n]);
```
